/**
 * Normalization service
 * Extracts latest guest message and full thread history from raw payload
 */

import { SCHEMA_VERSION, SOURCE_TYPES, CONTENT_TYPES, INGEST_METHODS } from "../types/schema.js";

/**
 * Identify if an email is from a guest (vs host)
 * @param {import("../types/knowledge-item.js").EmailMessage} message - Email message
 * @returns {boolean} - True if message is from a guest
 */
function isGuestMessage(message) {
  // Simple heuristic: guest messages typically don't come from host domains
  // This can be enhanced with property-specific configuration later
  const hostDomains = ["capehost.ai", "capehost.com"]; // Add more host domains as needed

  if (!message.from) {
    return false;
  }

  const fromEmail = message.from.toLowerCase();
  return !hostDomains.some((domain) => fromEmail.includes(`@${domain}`));
}

/**
 * Extract the latest guest message from thread
 * @param {import("../types/knowledge-item.js").EmailMessage[]} messages - Array of messages
 * @returns {import("../types/knowledge-item.js").EmailMessage|null} - Latest guest message or null
 */
export function extractLatestGuestMessage(messages) {
  if (!messages || messages.length === 0) {
    return null;
  }

  // Sort messages by date (newest first)
  const sortedMessages = [...messages].sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateB - dateA; // Descending order
  });

  // Find the latest guest message
  for (const message of sortedMessages) {
    if (isGuestMessage(message)) {
      return message;
    }
  }

  // If no guest message found, return null (might be host-to-host thread)
  return null;
}

/**
 * Build full thread text from messages
 * @param {import("../types/knowledge-item.js").EmailMessage[]} messages - Array of messages
 * @returns {string} - Full thread text
 */
export function buildFullThreadText(messages) {
  if (!messages || messages.length === 0) {
    return "";
  }

  // Sort messages by date (oldest first) for chronological thread
  const sortedMessages = [...messages].sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);
    return dateA - dateB; // Ascending order
  });

  return sortedMessages
    .map((msg, index) => {
      const header = `--- Message ${index + 1} ---
From: ${msg.from}
To: ${msg.to}
Date: ${msg.date}
Subject: ${msg.subject}

`;
      const body = msg.bodyPlain || msg.bodyHtml || "";
      return header + body;
    })
    .join("\n\n");
}

/**
 * Normalize webhook payload into knowledge item structure
 * @param {import("../types/knowledge-item.js").WebhookPayload} payload - Raw webhook payload
 * @param {string} source - Source type (default: gmail_webhook)
 * @param {string|null} property_id - Property identifier (optional, will use payload.property_id if not provided)
 * @param {string|null} booking_id - Booking identifier (optional, will use payload.booking_id if not provided)
 * @returns {import("../types/knowledge-item.js").KnowledgeItem} - Normalized knowledge item
 */
export function normalizeWebhookPayload(
  payload,
  source = SOURCE_TYPES.GMAIL_WEBHOOK,
  property_id = null,
  booking_id = null
) {
  const messages = payload.messages || [];
  const latestGuestMessage = extractLatestGuestMessage(messages);
  const fullThreadText = buildFullThreadText(messages);

  // Extract timestamps
  const timestamps = messages.map((m) => m.date || m.id);

  // Get first message for metadata
  const firstMessage = messages[0] || {};
  const lastMessage = messages[messages.length - 1] || {};

  // Use last message subject (most recent)
  const subject = lastMessage.subject || firstMessage.subject || "No Subject";

  // Determine from/to based on latest message
  const from = lastMessage.from || firstMessage.from || "";
  const to = lastMessage.to || firstMessage.to || "";

  const normalized = {
    latest_guest_message: latestGuestMessage
      ? {
          id: latestGuestMessage.id,
          date: latestGuestMessage.date,
          from: latestGuestMessage.from,
          subject: latestGuestMessage.subject,
          bodyPlain: latestGuestMessage.bodyPlain,
        }
      : null,
    full_thread_text: fullThreadText,
    message_count: messages.length,
    subject,
    from,
    to,
    timestamps,
  };

  // Use schema_version from payload, fall back to current SCHEMA_VERSION
  const schemaVersion = payload.schema_version || SCHEMA_VERSION;

  // Extract property_id and booking_id from payload if not provided as parameters
  const finalPropertyId = property_id || payload.property_id || null;
  const finalBookingId = booking_id || payload.booking_id || null;

  // Use source from payload if available, otherwise use parameter
  const finalSource = payload.source || source;

  return {
    id: null, // Will be generated by storage adapter
    schema_version: schemaVersion,
    created_at: new Date(),
    source: finalSource,
    ingest_method: INGEST_METHODS.WEBHOOK,
    content_type: CONTENT_TYPES.EMAIL_MESSAGE,
    property_id: finalPropertyId,
    booking_id: finalBookingId,
    external_thread_id: payload.threadId || null,
    raw_payload: payload,
    normalized,
  };
}
